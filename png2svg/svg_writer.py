"""
SVG writer module for PNG2SVG system.
Generates semantically-rich SVG output with proper layers and styles.
"""

import svgwrite
from svgwrite import mm, px
import logging
from pathlib import Path
from typing import List, Dict, Optional, Tuple
import math

from .config import Config
from .topology import Graph, Node, Edge, Relation, LineSeg, CircleArc


def write(img_path: str, graph: Graph, cfg: Config) -> str:
    """
    Write topology graph to SVG file.
    
    - Create layered structure: <g id="main">, <g id="aux">, <g id="symbols">, <g id="labels">
    - Apply unified styles with stroke widths and dash patterns
    - Define markers for arrows, right angles, tick marks
    - Embed semantic data in data-* attributes
    - Scale coordinates based on configuration
    - Return SVG file path
    
    Args:
        img_path: Original image path (for naming output)
        graph: Topology graph with optimized geometry
        cfg: Configuration object
        
    Returns:
        Path to generated SVG file
    """
    logger = logging.getLogger('png2svg.svg_writer')
    
    # Prepare output path
    input_name = Path(img_path).stem
    output_path = Path(cfg.output_dir) / f"{input_name}.svg"
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Calculate canvas size
    canvas_width, canvas_height = calculate_canvas_size(graph, cfg)
    
    # Create SVG drawing with validation disabled to allow data attributes
    dwg = svgwrite.Drawing(
        str(output_path),
        size=(f'{canvas_width}px', f'{canvas_height}px'),
        debug=False,
        viewBox=f'0 0 {canvas_width} {canvas_height}'
    )
    
    # Add metadata
    dwg.set_desc(title='Mathematical Diagram', 
                 desc='Generated by PNG2SVG system')
    
    # Define styles and markers
    add_defs_and_styles(dwg, cfg)
    
    # Create layer groups
    g_main = dwg.g(id='main', stroke='black', fill='none', 
                   stroke_width=cfg.svg.stroke_main)
    g_aux = dwg.g(id='auxiliary', stroke='gray', fill='none', 
                  stroke_width=cfg.svg.stroke_aux)
    g_symbols = dwg.g(id='symbols', stroke='black', fill='none', 
                      stroke_width=1)
    g_labels = dwg.g(id='labels', font_family='Arial', font_size='14px', 
                     fill='black')
    
    # Draw edges (lines and circles)
    draw_edges(dwg, g_main, g_aux, graph, cfg)
    
    # Draw nodes (points)
    draw_nodes(dwg, g_symbols, graph, cfg)
    
    # Draw text labels
    draw_labels(dwg, g_labels, graph, cfg)
    
    # Draw special symbols
    draw_symbols(dwg, g_symbols, graph, cfg)
    
    # Add groups to drawing
    dwg.add(g_main)
    dwg.add(g_aux)
    dwg.add(g_symbols)
    dwg.add(g_labels)
    
    # Save SVG
    dwg.save()
    
    logger.info(f"SVG saved to: {output_path}")
    return str(output_path)


def calculate_canvas_size(graph: Graph, cfg: Config) -> Tuple[int, int]:
    """
    Calculate canvas size based on graph bounds.
    
    Args:
        graph: Topology graph
        cfg: Configuration object
        
    Returns:
        (width, height) in pixels
    """
    if not graph.nodes and not graph.edges:
        return 800, 600  # Default size
    
    # Find bounds
    min_x = min_y = float('inf')
    max_x = max_y = float('-inf')
    
    # Check nodes
    for node in graph.nodes:
        min_x = min(min_x, node.x)
        min_y = min(min_y, node.y)
        max_x = max(max_x, node.x)
        max_y = max(max_y, node.y)
    
    # Check line endpoints
    for edge in graph.edges:
        if isinstance(edge.geom, LineSeg):
            min_x = min(min_x, edge.geom.p1[0], edge.geom.p2[0])
            min_y = min(min_y, edge.geom.p1[1], edge.geom.p2[1])
            max_x = max(max_x, edge.geom.p1[0], edge.geom.p2[0])
            max_y = max(max_y, edge.geom.p1[1], edge.geom.p2[1])
        elif isinstance(edge.geom, CircleArc):
            min_x = min(min_x, edge.geom.cx - edge.geom.r)
            min_y = min(min_y, edge.geom.cy - edge.geom.r)
            max_x = max(max_x, edge.geom.cx + edge.geom.r)
            max_y = max(max_y, edge.geom.cy + edge.geom.r)
    
    # Add padding
    padding = 50
    width = int((max_x - min_x + 2 * padding) * cfg.svg.scale)
    height = int((max_y - min_y + 2 * padding) * cfg.svg.scale)
    
    return max(width, 100), max(height, 100)


def add_defs_and_styles(dwg: svgwrite.Drawing, cfg: Config):
    """
    Add SVG definitions for markers and styles.
    
    Args:
        dwg: SVG drawing object
        cfg: Configuration object
    """
    defs = dwg.defs
    
    # Arrow marker
    arrow = defs.add(dwg.marker(
        id='arrow',
        insert=(8, 4),
        size=(8, 8),
        orient='auto',
        markerUnits='strokeWidth'
    ))
    arrow.add(dwg.path(
        d='M0,0 L8,4 L0,8 L3,4 z',
        fill='black'
    ))
    
    # Right angle marker (small square)
    right_angle = defs.add(dwg.marker(
        id='right_angle',
        insert=(0, 0),
        size=(10, 10),
        markerUnits='userSpaceOnUse'
    ))
    right_angle.add(dwg.rect(
        insert=(0, 0),
        size=(10, 10),
        fill='none',
        stroke='black',
        stroke_width=1
    ))
    
    # Tick mark patterns for equal length
    for i in range(1, 4):
        tick_pattern = defs.add(dwg.pattern(
            id=f'tick_{i}',
            size=(20, 10),
            patternUnits='userSpaceOnUse'
        ))
        for j in range(i):
            tick_pattern.add(dwg.line(
                start=(5 + j * 4, 0),
                end=(5 + j * 4, 10),
                stroke='black',
                stroke_width=1
            ))
    
    # Add CSS styles
    style = defs.add(dwg.style())
    style.append("""
        .dashed { stroke-dasharray: 6,6; }
        .dotted { stroke-dasharray: 2,2; }
        .hidden { stroke-dasharray: 4,2; opacity: 0.5; }
        .thick { stroke-width: 3; }
        .thin { stroke-width: 1; }
        .label { font-family: Arial, sans-serif; font-size: 14px; }
        .angle-label { font-size: 12px; font-style: italic; }
        .length-label { font-size: 11px; }
    """)
    
    dwg.add(defs)


def draw_edges(dwg: svgwrite.Drawing, g_main, g_aux, graph: Graph, cfg: Config):
    """
    Draw all edges (lines and circles) to appropriate layers.
    
    Args:
        dwg: SVG drawing object
        g_main: Main layer group
        g_aux: Auxiliary layer group
        graph: Topology graph
        cfg: Configuration object
    """
    for edge in graph.edges:
        # Choose layer based on role
        layer = g_aux if edge.role == 'aux' else g_main
        
        # Set attributes
        attrs = {
            'data-id': edge.id,
            'data-role': edge.role
        }
        
        # Add semantic attributes
        if edge.attrs.get('has_parallel_mark'):
            attrs['data-parallel'] = 'true'
        if edge.attrs.get('has_right_angle_symbol'):
            attrs['data-perpendicular'] = 'true'
        if edge.attrs.get('tick_marks'):
            attrs['data-tick-marks'] = str(edge.attrs['tick_marks'])
        if edge.attrs.get('length_label'):
            attrs['data-length'] = edge.attrs['length_label']
        
        if isinstance(edge.geom, LineSeg):
            draw_line_segment(dwg, layer, edge.geom, edge.attrs, attrs, cfg)
        elif isinstance(edge.geom, CircleArc):
            draw_circle_arc(dwg, layer, edge.geom, edge.attrs, attrs, cfg)


def draw_line_segment(dwg: svgwrite.Drawing, layer, line: LineSeg, 
                       edge_attrs: Dict, svg_attrs: Dict, cfg: Config):
    """
    Draw a line segment with appropriate style.
    
    Args:
        dwg: SVG drawing object
        layer: Layer group to add to
        line: Line segment geometry
        edge_attrs: Edge attributes
        svg_attrs: SVG element attributes
        cfg: Configuration object
    """
    x1, y1 = line.p1[0] * cfg.svg.scale, line.p1[1] * cfg.svg.scale
    x2, y2 = line.p2[0] * cfg.svg.scale, line.p2[1] * cfg.svg.scale
    
    # Create line element
    svg_line = dwg.line(
        start=(x1, y1),
        end=(x2, y2)
    )
    
    # Apply data attributes separately
    for attr_name, attr_value in svg_attrs.items():
        svg_line[attr_name] = attr_value
    
    # Apply dash pattern if dashed
    if line.dashed or edge_attrs.get('dashed'):
        svg_line['stroke-dasharray'] = cfg.svg.dash_pattern
    
    # Add arrow markers if present
    if edge_attrs.get('arrow_at_p1'):
        svg_line['marker-start'] = 'url(#arrow)'
    if edge_attrs.get('arrow_at_p2'):
        svg_line['marker-end'] = 'url(#arrow)'
    
    # Add tick marks for equal length
    if edge_attrs.get('tick_marks'):
        add_tick_marks(dwg, layer, (x1, y1), (x2, y2), edge_attrs['tick_marks'])
    
    layer.add(svg_line)


def draw_circle_arc(dwg: svgwrite.Drawing, layer, circle: CircleArc, 
                    edge_attrs: Dict, svg_attrs: Dict, cfg: Config):
    """
    Draw a circle or arc.
    
    Args:
        dwg: SVG drawing object
        layer: Layer group to add to
        circle: Circle/arc geometry
        edge_attrs: Edge attributes
        svg_attrs: SVG element attributes
        cfg: Configuration object
    """
    cx = circle.cx * cfg.svg.scale
    cy = circle.cy * cfg.svg.scale
    r = circle.r * cfg.svg.scale
    
    if circle.kind == 'circle' or (circle.theta1 == 0 and circle.theta2 == 360):
        # Full circle
        svg_circle = dwg.circle(
            center=(cx, cy),
            r=r
        )
        
        # Apply data attributes separately
        for attr_name, attr_value in svg_attrs.items():
            svg_circle[attr_name] = attr_value
            
        layer.add(svg_circle)
    else:
        # Arc
        theta1_rad = math.radians(circle.theta1)
        theta2_rad = math.radians(circle.theta2)
        
        # Calculate arc endpoints
        x1 = cx + r * math.cos(theta1_rad)
        y1 = cy + r * math.sin(theta1_rad)
        x2 = cx + r * math.cos(theta2_rad)
        y2 = cy + r * math.sin(theta2_rad)
        
        # Determine arc flags
        large_arc = 1 if abs(circle.theta2 - circle.theta1) > 180 else 0
        sweep = 1 if circle.theta2 > circle.theta1 else 0
        
        # Create arc path
        path = dwg.path(
            d=f'M {x1},{y1} A {r},{r} 0 {large_arc},{sweep} {x2},{y2}'
        )
        
        # Apply data attributes separately
        for attr_name, attr_value in svg_attrs.items():
            path[attr_name] = attr_value
            
        layer.add(path)


def draw_nodes(dwg: svgwrite.Drawing, layer, graph: Graph, cfg: Config):
    """
    Draw node points with labels.
    
    Args:
        dwg: SVG drawing object
        layer: Symbol layer group
        graph: Topology graph
        cfg: Configuration object
    """
    for node in graph.nodes:
        x = node.x * cfg.svg.scale
        y = node.y * cfg.svg.scale
        
        # Determine node style based on kind
        if node.kind == 'center':
            # Draw center point as small filled circle
            circle = dwg.circle(
                center=(x, y),
                r=3,
                fill='black',
                data_id=node.id,
                data_kind=node.kind
            )
            layer.add(circle)
        elif node.kind in ['endpoint', 'vertex', 'intersection']:
            # Draw as small dot
            circle = dwg.circle(
                center=(x, y),
                r=2,
                fill='black',
                opacity=0.5,
                data_id=node.id,
                data_kind=node.kind
            )
            layer.add(circle)
        
        # Special markers for midpoint, foot, etc.
        if node.kind == 'midpoint':
            # Draw midpoint marker
            add_midpoint_marker(dwg, layer, (x, y))
        elif node.kind == 'foot':
            # Draw perpendicular foot marker
            add_foot_marker(dwg, layer, (x, y))


def draw_labels(dwg: svgwrite.Drawing, layer, graph: Graph, cfg: Config):
    """
    Draw text labels for nodes.
    
    Args:
        dwg: SVG drawing object
        layer: Label layer group
        graph: Topology graph
        cfg: Configuration object
    """
    for node in graph.nodes:
        if node.tag:
            x = node.x * cfg.svg.scale
            y = node.y * cfg.svg.scale
            
            # Offset label slightly from point
            text_x = x + 5
            text_y = y - 5
            
            text = dwg.text(
                node.tag,
                insert=(text_x, text_y),
                class_='label',
                data_node=node.id
            )
            layer.add(text)
    
    # Draw angle values
    for node in graph.nodes:
        if hasattr(node, 'angle_value'):
            x = node.x * cfg.svg.scale
            y = node.y * cfg.svg.scale
            
            text = dwg.text(
                node.angle_value,
                insert=(x + 10, y + 10),
                class_='angle-label',
                data_node=node.id
            )
            layer.add(text)
    
    # Draw length labels on lines
    for edge in graph.edges:
        if edge.attrs.get('length_label') and isinstance(edge.geom, LineSeg):
            # Calculate midpoint of line
            mx = (edge.geom.p1[0] + edge.geom.p2[0]) / 2 * cfg.svg.scale
            my = (edge.geom.p1[1] + edge.geom.p2[1]) / 2 * cfg.svg.scale
            
            text = dwg.text(
                edge.attrs['length_label'],
                insert=(mx, my - 5),
                class_='length-label',
                data_edge=edge.id
            )
            layer.add(text)


def draw_symbols(dwg: svgwrite.Drawing, layer, graph: Graph, cfg: Config):
    """
    Draw special symbols (right angles, arc angles, etc.).
    
    Args:
        dwg: SVG drawing object
        layer: Symbol layer group
        graph: Topology graph
        cfg: Configuration object
    """
    # Draw right angle symbols
    for relation in graph.relations:
        if relation.type == 'perpendicular' and relation.conf > 0.8:
            draw_right_angle_symbol(dwg, layer, graph, relation, cfg)
    
    # Draw angle arcs
    angle_vertices = {}
    for edge in graph.edges:
        if isinstance(edge.geom, LineSeg) and edge.attrs.get('angle_arcs'):
            vertex_id = edge.attrs.get('angle_vertex')
            if vertex_id:
                if vertex_id not in angle_vertices:
                    angle_vertices[vertex_id] = []
                angle_vertices[vertex_id].append(edge)
    
    for vertex_id, edges in angle_vertices.items():
        if len(edges) >= 2:
            vertex = next((n for n in graph.nodes if n.id == vertex_id), None)
            if vertex:
                arc_count = edges[0].attrs.get('angle_arcs', 1)
                draw_angle_arcs(dwg, layer, vertex, edges[:2], arc_count, cfg)


def draw_right_angle_symbol(dwg: svgwrite.Drawing, layer, graph: Graph, 
                            relation: Relation, cfg: Config):
    """
    Draw right angle symbol at line intersection.
    
    Args:
        dwg: SVG drawing object
        layer: Symbol layer
        graph: Topology graph
        relation: Perpendicular relation
        cfg: Configuration object
    """
    if len(relation.members) < 2:
        return
    
    # Find the two lines
    line1 = next((e for e in graph.edges if e.id == relation.members[0]), None)
    line2 = next((e for e in graph.edges if e.id == relation.members[1]), None)
    
    if not line1 or not line2:
        return
    
    if not isinstance(line1.geom, LineSeg) or not isinstance(line2.geom, LineSeg):
        return
    
    # Find intersection point
    from shapely.geometry import LineString
    geom1 = LineString([line1.geom.p1, line1.geom.p2])
    geom2 = LineString([line2.geom.p1, line2.geom.p2])
    
    if not geom1.intersects(geom2):
        return
    
    intersection = geom1.intersection(geom2)
    if intersection.geom_type != 'Point':
        return
    
    ix = intersection.x * cfg.svg.scale
    iy = intersection.y * cfg.svg.scale
    
    # Draw small square at intersection
    size = 10
    rect = dwg.rect(
        insert=(ix - size/2, iy - size/2),
        size=(size, size),
        fill='none',
        stroke='black',
        stroke_width=1,
        data_type='right_angle'
    )
    layer.add(rect)


def draw_angle_arcs(dwg: svgwrite.Drawing, layer, vertex: Node, 
                     edges: List[Edge], arc_count: int, cfg: Config):
    """
    Draw angle arc markers.
    
    Args:
        dwg: SVG drawing object
        layer: Symbol layer
        vertex: Vertex node
        edges: Two edges forming the angle
        arc_count: Number of arc marks (1, 2, or 3)
        cfg: Configuration object
    """
    vx = vertex.x * cfg.svg.scale
    vy = vertex.y * cfg.svg.scale
    
    # Calculate angle directions
    angles = []
    for edge in edges:
        if isinstance(edge.geom, LineSeg):
            # Find which endpoint is the vertex
            dist1 = math.hypot(edge.geom.p1[0] - vertex.x, edge.geom.p1[1] - vertex.y)
            dist2 = math.hypot(edge.geom.p2[0] - vertex.x, edge.geom.p2[1] - vertex.y)
            
            if dist1 < dist2:
                # p1 is vertex, use direction to p2
                angle = math.atan2(edge.geom.p2[1] - vertex.y, edge.geom.p2[0] - vertex.x)
            else:
                # p2 is vertex, use direction to p1
                angle = math.atan2(edge.geom.p1[1] - vertex.y, edge.geom.p1[0] - vertex.x)
            
            angles.append(angle)
    
    if len(angles) < 2:
        return
    
    # Draw arc marks
    base_radius = 20
    for i in range(arc_count):
        radius = base_radius + i * 3
        
        # Calculate arc path
        start_angle = min(angles)
        end_angle = max(angles)
        
        if end_angle - start_angle > math.pi:
            start_angle, end_angle = end_angle, start_angle + 2 * math.pi
        
        x1 = vx + radius * math.cos(start_angle)
        y1 = vy + radius * math.sin(start_angle)
        x2 = vx + radius * math.cos(end_angle)
        y2 = vy + radius * math.sin(end_angle)
        
        large_arc = 1 if abs(end_angle - start_angle) > math.pi else 0
        
        path = dwg.path(
            d=f'M {x1},{y1} A {radius},{radius} 0 {large_arc},1 {x2},{y2}',
            fill='none',
            stroke='black',
            stroke_width=1,
            data_type='angle_arc',
            data_count=str(arc_count)
        )
        layer.add(path)


def add_tick_marks(dwg: svgwrite.Drawing, layer, p1: Tuple[float, float], 
                   p2: Tuple[float, float], tick_count: int):
    """
    Add tick marks to indicate equal length.
    
    Args:
        dwg: SVG drawing object
        layer: Layer to add to
        p1: Start point
        p2: End point
        tick_count: Number of tick marks
    """
    # Calculate midpoint
    mx = (p1[0] + p2[0]) / 2
    my = (p1[1] + p2[1]) / 2
    
    # Calculate perpendicular direction
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    length = math.hypot(dx, dy)
    
    if length < 1e-6:
        return
    
    # Perpendicular unit vector
    px = -dy / length
    py = dx / length
    
    # Draw tick marks
    tick_length = 6
    spacing = 4
    
    for i in range(tick_count):
        offset = (i - (tick_count - 1) / 2) * spacing
        
        tx = mx + offset * dx / length
        ty = my + offset * dy / length
        
        line = dwg.line(
            start=(tx - px * tick_length/2, ty - py * tick_length/2),
            end=(tx + px * tick_length/2, ty + py * tick_length/2),
            stroke='black',
            stroke_width=1,
            data_type='tick_mark'
        )
        layer.add(line)


def add_midpoint_marker(dwg: svgwrite.Drawing, layer, point: Tuple[float, float]):
    """
    Add midpoint marker symbol.
    
    Args:
        dwg: SVG drawing object
        layer: Symbol layer
        point: Point coordinates
    """
    x, y = point
    
    # Draw small perpendicular lines
    size = 4
    layer.add(dwg.line(
        start=(x - size, y),
        end=(x + size, y),
        stroke='black',
        stroke_width=1,
        data_type='midpoint_marker'
    ))
    layer.add(dwg.line(
        start=(x, y - size),
        end=(x, y + size),
        stroke='black',
        stroke_width=1,
        data_type='midpoint_marker'
    ))


def add_foot_marker(dwg: svgwrite.Drawing, layer, point: Tuple[float, float]):
    """
    Add perpendicular foot marker.
    
    Args:
        dwg: SVG drawing object
        layer: Symbol layer
        point: Point coordinates
    """
    x, y = point
    
    # Draw small right angle symbol
    size = 6
    path = dwg.path(
        d=f'M {x},{y-size} L {x},{y} L {x+size},{y}',
        fill='none',
        stroke='black',
        stroke_width=1,
        data_type='foot_marker'
    )
    layer.add(path)